\documentclass{beamer}

\usepackage{svg}
\usepackage{amsmath}
\usepackage{textcomp}
\usepackage{listings}

\lstset{%
    language=[latex]tex,
    breaklines=true}

\lstset{literate={→}{$\rightarrow$}1}
\DeclareUnicodeCharacter{00A0}{ }
\DeclareUnicodeCharacter{2192}{\dash}

\newsavebox{\anatomyOfCaseBox}

\newsavebox{\exampleMaybe}
\newsavebox{\exampleList}
\newsavebox{\exampleString}
\newsavebox{\exampleImagination}

\newsavebox{\exampleInstantiationHelper}

\newsavebox{\caseGenCode}
\newsavebox{\caseGenWat}

\newcommand\omicron{o}

\usepackage[utf8]{inputenc}
\usetheme{Madrid}

\title[Disjoint Union Types]{Disjoint Union Types in P0}
\subtitle{Project 9 / Group 8}
\author{Jason Balaci}
\institute{McMaster University}
\date{April 2021}


\AtBeginSection[]
{
  \begin{frame}
    \frametitle{Table of Contents}
    \tableofcontents[currentsection]
  \end{frame}
}

\begin{document}


\frame{\titlepage}

\begin{frame}
\frametitle{Table of Contents}
\tableofcontents
\end{frame}

\section{Objective \& Implementation}

\begin{frame}
\frametitle{What are Disjoint Union Types?}

\begin{itemize}
 % TODO
 \item<1-> Something 1
 \item<2-> Something 2
 \item<3-> Something 3
 \item<4-> In functional programming languages, they are often known as \textbf{Algebraic Data Types} (ADTs for short).
\end{itemize}

\end{frame}

\begin{frame}
\frametitle{What do they look like?}
% TODO: Code examples
% TODO: Instantiation examples
\end{frame}

\begin{lrbox}{\anatomyOfCaseBox}
\begin{lstlisting}[language=Pascal, basicstyle=\footnotesize]
case <variable> of {
    [nil: <stmtSuite>]
    Kind A: <stmtSuite>
    Kind B: <stmtSuite>
    ...
    ...
    [default: <stmtSuite>]
    ... or ...
    [default nothing]
}
\end{lstlisting}
\end{lrbox}

\begin{frame}
 \frametitle{How do we use DUTs?}
 \framesubtitle{The anatomy of a \texttt{case} statement.}
    \begin{columns}[T,onlytextwidth]
        \begin{column}{.5\textwidth}
            \begin{minipage}{\textwidth}
                \begin{itemize}
                    \item<1-> \texttt{case}s are the only way to access data inside of DUTs.
                    \item<2-> Check if DUTs were \textit{initialized} using a \texttt{nil} case at the start.
                    \item<3-> \texttt{case} on any of the variants you'd like to.
                    \item<4-> \texttt{default} case allows you to perform either a statement suite or a no-op on all non-covered cases. 
                    \item<5-> Within the statement suite of each variant \texttt{case}, the variable in question is assumed to be an instance of the variant's record.
                \end{itemize}
            \end{minipage}
        \end{column}
        \begin{column}{.45\textwidth}
            \begin{onlyenv}
                \begin{minipage}{\textwidth}
                    \usebox{\anatomyOfCaseBox}
                    \begin{alertblock}{\footnotesize Exhaust your \texttt{case}s!}<6->
                        {\footnotesize If you create a non-exhaustive \texttt{case} statement, the compiler will warn you.}
                    \end{alertblock}
                \end{minipage}
            \end{onlyenv}
        \end{column}
    \end{columns}
\end{frame}

\section{Examples}


\begin{lrbox}{\exampleMaybe}
\begin{lstlisting}[language=Pascal, basicstyle=\tiny]
type Maybe = Just(value: integer)
           | Nothing

procedure valOr(v: Maybe, n: integer) → (r: integer)
    case v of {
        Just:
            r := v.value
        default:
            r := n
    }

program Main
    var maybe: Maybe

    maybe <- Nothing()
    writeln(valOr(maybe, -1))

    maybe <- Just(1111)
    writeln(valOr(maybe, 0))


\end{lstlisting}
\end{lrbox}

\begin{frame}
\frametitle{Example: Maybe}
\usebox{\exampleMaybe}

\begin{block}{Output}<2->
-1\\
1111
\end{block}
\end{frame}


\begin{lrbox}{\exampleList}
\begin{lstlisting}[language=Pascal, basicstyle=\tiny]
type List = Cons(head: integer, tail: List)
          | Nil

procedure upToList(n: integer) → (l: List)
    if n < 1 then l := Nil() else l := Cons(n, upToList(n-1))

procedure consumeList(l: List)
    case l of {
        Cons: writeln(l.head); consumeList(l.tail)
        default nothing
    }

procedure sumList(l: List) → (n: integer)
    case l of {
        Cons: n := sumList(l.tail) + l.head
        default: n := 0
    }

program Main
    var myList: List
    myList := upToList(5)
    consumeList(myList)
    writeln(sumList(myList))
\end{lstlisting}
\end{lrbox}

\begin{frame}
\frametitle{Example: Lists}
    \begin{columns}[T,onlytextwidth]
        \begin{column}{.8\textwidth}
            \begin{minipage}{\textwidth}
                \usebox{\exampleList}
            \end{minipage}
        \end{column}
        \begin{column}{.2\textwidth}
            \begin{onlyenv}
                \begin{minipage}{\textwidth}
                    \begin{block}{Output}<2->
                        5\\
                        4\\
                        3\\
                        2\\
                        1\\
                        15
                    \end{block}
                \end{minipage}
            \end{onlyenv}
        \end{column}
    \end{columns}
\end{frame}


\begin{lrbox}{\exampleString}
\begin{lstlisting}[language=Pascal,basicstyle=\tiny, literate={α}{$\alpha$}1{ω}{$\omega$}2]
type String = SCons(ch: integer, tail: String)
            | SNil

procedure printStr(s: String, ln: boolean)
    case s of {
        SCons: writeChar(s.ch); printStr(s.tail, ln)
        default: if ln then writeNewLine()
    }

// inclusively generating alphabets in a range
procedure genBetwn(start: integer, end: integer) -> (s: String)
    var ch: integer
    ch := end
    s := SNil()
    
    while start <= end do
        s, start, ch := SCons(ch, s), start + 1, ch - 1

program Main
    // print capital letters
    printStr(genBetwn('A', 'Z'), true)
    
    // print lowercase letters
    printStr(genBetwn('a', 'z'), true)
    
    // print numbers 0-9
    printStr(genBetwn('0', '9'), true)
    
    // print Greek letters
    printStr(genBetwn('α', 'ω'), true)

\end{lstlisting}
\end{lrbox}

\begin{frame}
\frametitle{Example: Strings}
\framesubtitle{... lists in disguise?}
    \begin{columns}[T,onlytextwidth]
        \begin{column}{.65\textwidth}
            \begin{minipage}{\textwidth}
                \usebox{\exampleString}
            \end{minipage}
        \end{column}
        \begin{column}{.35\textwidth}
            \begin{onlyenv}
                \begin{minipage}{\textwidth}
                    \begin{block}{Output}<2->\tiny
                        ABCDEFGHIJKLMNOPQRSTUVWXYZ\\
                        abcdefghijklmnopqrstuvwxyz\\
                        0123456789\\
                        $\alpha\beta\gamma\delta\epsilon\zeta\eta\theta\iota\kappa\lambda\mu\nu\xi\omicron\pi\rho\sigma\tau\upsilon\phi\chi\psi\omega$
                    \end{block}
                    
                    \ \\
                    
                    \begin{block}{Note}<1->\tiny
                        We convert single-quoted characters into their UTF-8 integer representation when reading in P0 programs.
                    \end{block}
                \end{minipage}
            \end{onlyenv}
        \end{column}
    \end{columns}
\end{frame}



\begin{lrbox}{\exampleImagination}
\begin{lstlisting}[language=Pascal,basicstyle=\tiny]
type RainbowColour = Red | Orange | Yellow | Green | Blue | Indigo | Violet

type Either = Left(value: integer)
            | Right(value: boolean)

type Tree = Branch(left: Tree, right: Tree)
          | Leaf(value: integer)

type Expr = Add(left: Expr, right: Expr)
          | Sub(left: Expr, right: Expr)
          | Mul(left: Expr, right: Expr)
          | Div(num: Expr, den: Expr)
          | Pow(base: Expr, exponent: Expr)
          | Int(value: integer)

type StringIntMap = SIMCons(key: String, value: integer, tail: StringIntMap)
                  | SIMEmpty

\end{lstlisting}
\end{lrbox}

\begin{frame}
\frametitle{Other Examples}
    
\usebox{\exampleImagination}

\begin{block}{Remark}
Modelling is nice with disjoint union types!
\end{block}
\end{frame}

\section{Implementation Evaluation and Notes}

\begin{frame}[fragile]
\frametitle{Focal Grammar Changes}

\begin{itemize}
 \item<1-> Disjoint union type declarations
    {\small \begin{verbatim}
type ::=
    ident ["(" typedIds ")"] {"|" ident ["(" typedIds ")"]} 
    | ...
            \end{verbatim}}

 \item<2-> \texttt{case} statements
{\small \begin{verbatim}
statement ::= ... | "case" expression "of" "{" INDENT 
                ["nil" ":" statementSuite] 
                {ident ":" statementSuite} 
                ["default" (":" statementSuite | "nothing")] 
               DEDENT "}"
    \end{verbatim}}

\end{itemize}

\end{frame}


\begin{frame}
\frametitle{Supplementary Grammar and Procedure Changes}

\begin{itemize}
 \item<1-> Single-value returning procedures may be used ``in-place'' in expressions
 \item<2-> Single characters wrapped in single-quotes (\textbf{\texttt{`a'}}) is a syntactic sugar for converting single utf-8 characters into P0 integers
 \item<3-> ``$<-$'' and ``$->$'' as alternatives for ``$\leftarrow$'' and ``$\rightarrow$'', respectively
 \item<4-> ``$>=$'' and ``$<=$'' as alternatives for ``$\geq$'' and ``$\leq$'', respectively
 \item<5-> ``$*$'' as an alternative for ``$\times$''
 \item<6-> Standard procedures
 \begin{itemize}
  \item \texttt{write} - no longer prints a newline character
  \item \texttt{writeln} - writes single integer to std. out. with a newline afterwards
  \item \texttt{writeChar} - writes single integer converted into a utf-8 character to std. out.
  \item \texttt{writeCharLn} - writes single integer converted into a utf-8 character to std. out. with a newline afterwards
  \item \texttt{writeNewLine} - writes a newline character to std. out.
 \end{itemize}
\end{itemize}

\end{frame}


\begin{lrbox}{\caseGenCode}
\begin{lstlisting}[language=Pascal,basicstyle=\tiny]
type Colour = R | G | Unknown

procedure printCol(col: Colour)
    case col of {
        nil: writeCharLn('?')
        R: writeCharLn('R')
        G: writeCharLn('G')
        default: writeCharLn('?')
    }

\end{lstlisting}
\end{lrbox}


\begin{lrbox}{\caseGenWat}
\begin{lstlisting}[language=Pascal,basicstyle=\tiny]
...
local.get $col
i32.load
i32.const 0        ;; check if nil
i32.eq
if                 ;; if it is nil
i32.const 63
call $writeCharLn  ;; print '?'
else               ;; otherwise
local.get $col
i32.load
i32.const 1        ;; check if `R`
i32.eq
if                 ;; if it is `R`
i32.const 82
call $writeCharLn  ;; print 'R'
else               ;; otherwise
local.get $col
i32.load
i32.const 2        ;; check if `G`
i32.eq
if                 ;; if it is `G`
i32.const 71
call $writeCharLn  ;; print 'G'
else
i32.const 63       ;; otherwise, default
call $writeCharLn  ;; print '?'
end
end
end
\end{lstlisting}
\end{lrbox}


\begin{frame}
 \frametitle{Example: \texttt{case} WebAssembly Generation}
    \begin{columns}[T,onlytextwidth]
        \begin{column}{.40\textwidth}
            \begin{minipage}{\textwidth}
                {\footnotesize For example, the WebAssembly code on the right-hand side for the below \texttt{case} statement.}
                \ \\ \ \\ \ \\
                \usebox{\caseGenCode}
            \end{minipage}
        \end{column}
        \begin{column}{.50\textwidth}
            \begin{minipage}{\textwidth}
                \usebox{\caseGenWat}
            \end{minipage}
        \end{column}
    \end{columns}
\end{frame}

\begin{frame}
\frametitle{Memory Impact \& Management}

Each instance of a DUT is located on the heap, and instances of local/global DUTs are pointers to the locations of their corresponding DUT on the heap.
\begin{itemize}
 \item <1-> Size of an allocation depends on the size of the variant being instantiated
 \item Offsets to accessing variables work similar to records, with a 4 byte offset for the variant id.
\end{itemize}

\begin{figure}
  \includesvg[width=0.9\textwidth]{../docs/img/memory_compressed.svg}
\end{figure}
\end{frame}

\begin{frame}
\frametitle{Example: Lists in Memory}
\begin{figure}
  \includesvg[width=0.9\textwidth]{../docs/img/memory_example_list_compressed.svg}
\end{figure}
\end{frame}


\begin{frame}
\frametitle{Notable Design Decisions}

\begin{itemize}
 \item<1-> The first 4 bytes of a program are to be always initialized to 0 so that we can always have uninitialized DUT pointers pointing to it, then when this uninitialized DUT is read in, we will always see that the ``instance" has $kindId = 0$, meaning it hasn't been instantiated.
 \item<2-> When DUTs are read in, we create ``helper functions" for each DUT variant. These ``helper functions" are then used whenever we want to instantiate any particular DUT variant. DUT variant instantiation is hence secretly just a function call (to some function that creates a DUT on the heap and returns it's memory location).
 \item<3-> Disjoint union type variants are mutable records. You may modify the values of a DUT variant only when \texttt{case}ing on it from within it's case. 
 \item<4-> DUT variant kind identifiers are immutable!
\end{itemize}
\end{frame}

\begin{lrbox}{\exampleInstantiationHelper}
\begin{lstlisting}[language=Lisp,basicstyle=\tiny]
(func $__mk_Cons (param $head i32) (param $tail i32) (result i32)
global.get $_memsize         ;; get known unused memory location
i32.const 1                  ;; get Cons's kind index
i32.store                    ;; store it
global.get $_memsize         ;; get known unused memory location
i32.const 4                  ;; get offset of the next type
i32.add                      ;; impose offset onto total memory size
local.get $head              ;; get param head
i32.store                    ;; store it in it's area
global.get $_memsize         ;; get known unused memory location
i32.const 8                  ;; get offset of the next type
i32.add                      ;; impose offset onto total memory size
local.get $tail              ;; get param tail
i32.store                    ;; store it in it's area
global.get $_memsize         ;; get global memory size
global.get $_memsize         ;; get global memory size (again)
i32.const 12                 ;; get size of kind (Cons)
i32.add                      ;; add to memory size
global.set $_memsize         ;; set memory size, leftover i32 on stack which is the returned pointer to the generated Cons
)
\end{lstlisting}
\end{lrbox}

\begin{frame}
 \frametitle{Example of DUT instantiation helper}
 \framesubtitle{This function is used when wanting to instantiate a ``Cons'' variant (of a List).}
 \usebox{\exampleInstantiationHelper}
\end{frame}


\begin{frame}
\frametitle{Notes on Runtimes}
\begin{itemize}
    \item<1-> When working with DUTs/ADTs, we often tend to create recursive algorithms...
    \item<2-> This causes issues for \textbf{pywasm}
    \begin{itemize}
     \item <.-> Due to being interpreted in Python, a recursive call stack size limitation is imposed onto our programs.
    \end{itemize}

    \item<3-> Thankfully, \textbf{wasmer} has no issues!
    \item<4-> In-browser WebAssembly execution also has no issues, but we don't ship a web browser with the compiler.
\end{itemize}
\end{frame}

\section{Future Work}

\begin{frame}

\begin{itemize}
 \item<1-> Type variables!
 \begin{itemize}
  \item<.-> Polymorphic disjoint union types! No more StringLists, IntLists, BooleanLists, etc!
  \item More code reuse!
 \end{itemize}
 
 \item<2-> More built-in types and syntactic sugars
 \begin{itemize}
 \item<.-> Strings, Lists, Maps as a basic set of built-in DUTs
 \item Stronger syntactic sugar for String generation (e.g., ``abcd..." for quickly instantiating large strings)
 \end{itemize}
 
 \item<3-> Improved Memory Management
 \begin{itemize}
  \item<.-> Memory freeing!
  \item Memory reuse!
  \item Allocation specialization for built-in DUTs!
 \end{itemize}

\end{itemize}

\end{frame}

\begin{frame}
\frametitle{References}
% TODO: References
\end{frame}


\end{document}
