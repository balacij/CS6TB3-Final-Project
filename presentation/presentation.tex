\documentclass{beamer}

\usepackage{svg}
\usepackage{amsmath}
\usepackage{textcomp}
\usepackage{listings}

\lstset{%
    language=[latex]tex,
    breaklines=true}

\lstset{literate={→}{$\rightarrow$}1}
\DeclareUnicodeCharacter{00A0}{ }
\DeclareUnicodeCharacter{2192}{\dash}

\newsavebox{\anatomyOfCaseBox}

\newsavebox{\exampleMaybe}
\newsavebox{\exampleList}
\newsavebox{\exampleString}
\newsavebox{\exampleImagination}

\newcommand\omicron{o}

\usepackage[utf8]{inputenc}
\usetheme{Madrid}

\title[Disjoint Union Types]{Disjoint Union Types in P0}
\subtitle{Project 9 / Group 8}
\author{Jason Balaci}
\institute{McMaster University}
\date{April 2021}


\AtBeginSection[]
{
  \begin{frame}
    \frametitle{Table of Contents}
    \tableofcontents[currentsection]
  \end{frame}
}

\begin{document}


\frame{\titlepage}

\begin{frame}
\frametitle{Table of Contents}
\tableofcontents
\end{frame}

\section{Objective \& Implementation}

\begin{frame}
\frametitle{What are Disjoint Union Types?}

% TODO: 
\end{frame}

\begin{frame}
\frametitle{What do they look like?}
% TODO: Code examples
% TODO: Instantiation examples
\end{frame}

\begin{frame}
\frametitle{Grammar Changes}

\begin{itemize}
 \item<1-> Text visible on slide 1
 \item<2-> Text visible on slide 2
 \item<3-> Text visible on slide 3
 \item<4-> Text visible on slide 4
 % TODO:
\end{itemize}

\end{frame}


\begin{lrbox}{\anatomyOfCaseBox}
\begin{lstlisting}[language=Pascal, basicstyle=\footnotesize]
case <variable> of {
    [nil: <stmtSuite>]
    Kind A: <stmtSuite>
    Kind B: <stmtSuite>
    ...
    Kind Z: <stmtSuite>
    [default: <stmtSuite>]
    ... or ...
    [default nothing]
}
\end{lstlisting}
\end{lrbox}

\begin{frame}
 \frametitle{How do we use DUTs?}
 \framesubtitle{The anatomy of a \texttt{case} statement.}
    \begin{columns}[T,onlytextwidth]
        \begin{column}{.5\textwidth}
            \begin{minipage}{\textwidth}
                \begin{itemize}
                    \item<1-> \texttt{case}s are the only way to access data inside of DUTs.
                    \item<2-> Check if DUTs were \textit{initialized} using a \texttt{nil} case at the start.
                    \item<3-> \texttt{case} on any of the variants you'd like to.
                    \item<4-> \texttt{default} case allows you to perform either a statement suite or a no-op on all non-covered cases. 
                    \item<5-> Within the statement suite of each variant \texttt{case}, the variable in question is assumed to be an instance of the variant's record.
                \end{itemize}
            \end{minipage}
        \end{column}
        \begin{column}{.45\textwidth}
            \begin{onlyenv}
                \begin{minipage}{\textwidth}
                    \usebox{\anatomyOfCaseBox}
                    \begin{alertblock}{\footnotesize Exhaust your \texttt{case}s!}<6->
                        {\footnotesize If you create a non-exhaustive \texttt{case} statement, the compiler will warn you.}
                    \end{alertblock}
                \end{minipage}
            \end{onlyenv}
        \end{column}
    \end{columns}
\end{frame}

\begin{frame}
 \frametitle{\texttt{case} WebAssembly Generation}
 % TODO
\end{frame}

\section{Examples}


\begin{lrbox}{\exampleMaybe}
\begin{lstlisting}[language=Pascal, basicstyle=\tiny]
type Maybe = Just(value: integer)
           | Nothing

procedure valOr(v: Maybe, n: integer) → (r: integer)
    case v of {
        Just:
            r := v.value
        default:
            r := n
    }

program Main
    var maybe: Maybe

    maybe <- Nothing()
    writeln(valOr(maybe, -1))

    maybe <- Just(1111)
    writeln(valOr(maybe, 0))


\end{lstlisting}
\end{lrbox}

\begin{frame}
\frametitle{Example: Maybe}
\usebox{\exampleMaybe}

\begin{block}{Output}<2->
-1\\
1111
\end{block}
\end{frame}


\begin{lrbox}{\exampleList}
\begin{lstlisting}[language=Pascal, basicstyle=\tiny]
type List = Cons(head: integer, tail: List)
          | Nil

procedure upToList(n: integer) → (l: List)
    if n < 1 then l := Nil() else l := Cons(n, upToList(n-1))

procedure consumeList(l: List)
    case l of {
        Cons: writeln(l.head); consumeList(l.tail)
        default nothing
    }

procedure sumList(l: List) → (n: integer)
    case l of {
        Cons: n := sumList(l.tail) + l.head
        default: n := 0
    }

program Main
    var myList: List
    myList := upToList(5)
    consumeList(myList)
    writeln(sumList(myList))
\end{lstlisting}
\end{lrbox}

\begin{frame}
\frametitle{Example: Lists}
    \begin{columns}[T,onlytextwidth]
        \begin{column}{.8\textwidth}
            \begin{minipage}{\textwidth}
                \usebox{\exampleList}
            \end{minipage}
        \end{column}
        \begin{column}{.2\textwidth}
            \begin{onlyenv}
                \begin{minipage}{\textwidth}
                    \begin{block}{Output}<2->
                        5\\
                        4\\
                        3\\
                        2\\
                        1\\
                        15
                    \end{block}
                \end{minipage}
            \end{onlyenv}
        \end{column}
    \end{columns}
\end{frame}


\begin{lrbox}{\exampleString}
\begin{lstlisting}[language=Pascal,basicstyle=\tiny, literate={α}{$\alpha$}1{ω}{$\omega$}2]
type String = SCons(ch: integer, tail: String)
            | SNil

procedure printStr(s: String, ln: boolean)
    case s of {
        SCons: writeChar(s.ch); printStr(s.tail, ln)
        default: if ln then writeNewLine()
    }

// inclusively generating alphabets in a range
procedure genBetwn(start: integer, end: integer) -> (s: String)
    var ch: integer
    ch := end
    s := SNil()
    
    while start <= end do
        s, start, ch := SCons(ch, s), start + 1, ch - 1

program Main
    // print capital letters
    printStr(genBetwn('A', 'Z'), true)
    
    // print lowercase letters
    printStr(genBetwn('a', 'z'), true)
    
    // print numbers 0-9
    printStr(genBetwn('0', '9'), true)
    
    // print Greek letters
    printStr(genBetwn('α', 'ω'), true)

\end{lstlisting}
\end{lrbox}

\begin{frame}
\frametitle{Example: Strings}
\framesubtitle{... lists in disguise?}
    \begin{columns}[T,onlytextwidth]
        \begin{column}{.65\textwidth}
            \begin{minipage}{\textwidth}
                \usebox{\exampleString}
            \end{minipage}
        \end{column}
        \begin{column}{.35\textwidth}
            \begin{onlyenv}
                \begin{minipage}{\textwidth}
                    \begin{block}{Output}<2->\tiny
                        ABCDEFGHIJKLMNOPQRSTUVWXYZ\\
                        abcdefghijklmnopqrstuvwxyz\\
                        0123456789\\
                        $\alpha\beta\gamma\delta\epsilon\zeta\eta\theta\iota\kappa\lambda\mu\nu\xi\omicron\pi\rho\sigma\tau\upsilon\phi\chi\psi\omega$
                    \end{block}
                \end{minipage}
            \end{onlyenv}
        \end{column}
    \end{columns}
\end{frame}



\begin{lrbox}{\exampleImagination}
\begin{lstlisting}[language=Pascal]
% TODO: 
\end{lstlisting}
\end{lrbox}

\begin{frame}
\frametitle{Other Examples}
    
\usebox{\exampleImagination}

\begin{block}{Remark}
Sample text
\end{block}
\end{frame}

\section{Implementation Evaluation and Notes}

\begin{frame}
\frametitle{Memory Impact \& Management}

Each instance of a DUT is located on the heap, and instances of local/global DUTs are pointers to the locations of their corresponding DUT on the heap.
\begin{itemize}
 \item <1-> Size of an allocation depends on the size of the variant being instantiated
 \item Offsets to accessing variables work similar to records, with a 4 byte offset for the variant id.
\end{itemize}


\begin{figure}
  \includesvg[width=0.9\textwidth]{../docs/img/memory_compressed.svg}
\end{figure}
\end{frame}

\begin{frame}
\frametitle{Example: Lists in Memory}
\begin{figure}
  \includesvg[width=0.9\textwidth]{../docs/img/memory_example_list_compressed.svg}
\end{figure}
\end{frame}


\begin{frame}
\frametitle{Notable Design Decisions}

\begin{itemize}
 \item<1-> Text visible on slide 1
 \item<2-> Text visible on slide 2
 \item<3-> Text visible on slide 3
 \item<4-> Text visible on slide 4
\end{itemize}

\end{frame}

\begin{frame}
\frametitle{Notes on Runtimes}
\begin{itemize}
    \item<1-> When working with DUTs/ADTs, we often tend to create recursive algorithms...
    \item<2-> This causes issues for \textbf{pywasm}
    \begin{itemize}
     \item <.-> Due to being interpreted in Python, a recursive call stack size limitation is imposed onto our programs.
    \end{itemize}

    \item<3-> Thankfully, \textbf{wasmer} has no issues!
    \item<4-> In-browser WebAssembly execution also has no issues, but we don't ship a web browser with the compiler.
\end{itemize}
\end{frame}

\section{Future Work}

\begin{frame}

\begin{itemize}
 \item<1-> Type variables!
 \begin{itemize}
  \item<.-> Polymorphic disjoint union types! No more StringLists, IntLists, BooleanLists!
  \item More code reuse!
 \end{itemize}
 
 \item<2-> More built-in types and syntactic sugars
 \begin{itemize}
 \item<.-> Strings, Lists, Maps as a basic set of built-in DUTs
 \item Stronger syntactic sugar for String generation (e.g., ``abcd..." for quickly instantiating large strings)
 \end{itemize}
 
 \item<3-> Improved Memory Management
 \begin{itemize}
  \item<.-> Memory freeing!
  \item Memory reuse!
  \item Allocation specialization for built-in DUTs!
 \end{itemize}

\end{itemize}

\end{frame}

\begin{frame}
\frametitle{References}
\end{frame}


\end{document}
